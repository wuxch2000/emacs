;; ------------------------- 关于emacs regex的帮助 ---------------------------
;; 保留符是：$,^,.,*,+,?,[,],\
;; ( | 		是普通字符，除非转义
;; ?		表示可选，0或者1个
;; +		表示1个或者多个
;; *		表示0个或者多个

;; []		表示内部的字符是或的关系
;; 			如：gr[aeo]y匹配gray grey groy，同样的表示方法还有：gray|grey|groy，或者gr\(a\|e\|o\)y

;; ^		单独使用表示行首
;; $		表示行尾。
;; ^		可以表示否定，如[^abc]表示不是a b c 的所有字符
;; \<
;; \>		分别表示word的开始和结束。

;; \{n\}	表示重复n次
;; \{n,m\}	表示重复n至m次，m不写的话表示无限。\{0,\}等同于*

;; [[:alnum:]] 普通英文字符和数字
;; [[:alpha:]] 普通英文字符
;; [[:blank:]] blank和tab
;; [[:space:]] [[:blank:]]和newline,carriage return,and the likes
;; [[:cntrl:]] 控制字符
;; [[:digit:]] 数字
;; [[:graph:]] 可见字符(不是space/control characters/or the likes)
;; [[:lower:]] 小写字符
;; [[:upper:]] 大写字符
;; [[:print:]] [[:graph:]]和空格

;; \(...\)	有三种使用方式
;;  1-- 用于括起\|的内容，如：\(foo\|bar\)x匹配foox和barx
;;  2-- 用于括起复杂表达式，与* + ?结合使用，如：ba\(na\)*匹配bana,banana等
;;  3-- 记录匹配的子字符串，用于以后引用，引用方式为\n，n是1-9的数字。如果不希望记录，可以使用shy模式，
;; 			即：\(?:...\)

;; \`		表示字符串或buffer的开始
;; \'		表示字符串或buffer的结束
;; \=		表示当前位置
;; \b		表示word的开始和结束
;; \B		表示不是word的开始和结束
;; \sC		表示语法是C的字符，如\s-或\s 表示空格
;;      `whitespace'		(\s- in string notation)
;;      `punctuation'		(\s.)
;;      `word'			(\sw)
;;      `symbol'			(\s_)
;;      `open-parenthesis'		(\s()
;;      `close-parenthesis'	(\s))
;;      `expression-prefix'	(\s')
;;      `string-quote'		(\s")
;;      `paired-delimiter'		(\s$)
;;      `escape'			(\s\)
;;      `character-quote'		(\s/)
;;      `comment-start'		(\s<)
;;      `comment-end'		(\s>)
;;      `string-delimiter'		(\s|)
;;      `comment-delimiter'	(\s!)
;;  匹配中文字符：\cc
;; \t \n	表示tab和newline
;; C-Q      表示数据控制字符
;; C-Q C-J	表示换行符
;; C-Q C-M	表示^M
;; C-Q tab	表示^I(tab)
;; meta c	切换大小写敏感
;; meta e   编辑minibuffer
;; C-o      切换到occur
;; M-f      切换到query-replace

;; C-y		paste到regex串中
;; C-w		copy光标处的word到regex串中
;; M-x occur <RET> regexp <RET>			显示匹配的行
;; M-x how-many <RET> regexp <RET>		显示匹配的行数
;; M-x flush-lines <RET> regexp <RET>	删除匹配行
;; M-x keep-lines <RET> regexp <RET>	保留匹配行

;; query时的命令含义：
;; <space> y	替换
;; <delete> n	不替换
;; ,			输入其它替换内容
;; .			替换后结束
;; <return>	结束
;; !			全部替换后结束
;; ^			跳到上一次替换

;; 查找重复行的regexp:  \(.*^q^j\)\1+

;; ------------------------- 关于regex的帮助 ---------------------------


;; 补充一个BBS上的说明
;; * 正则表达式语法

;;       正则表达式(regular expressions, 缩写为regexp)是由几个特殊字符和一些普通
;;   字符组成，一个普通字符就是一个简单的正则表达式，仅仅可以匹配与自己相同的字
;;   符。而特殊字符包括“$”，“^”，“.”，“*”，“+”，“?”，“[”，“]”以
;;   及“\”。除非在一个字符前面有“\”，否则正则表达式中出现的任何其他字符都是
;;   普通字符，（当你在 Lisp 程序中使用正则表达式时，每一个“\”都必须写成两个，，
;;   因为需要对字符串中的“\”转义，请看下面的例子。）

;;       例如，“f”不是特殊字符，是普通字符，因此“f”是一个正则表达式，它仅仅
;;   匹配串“f”。（不匹配“ff”。）同样“o”是仅匹配串“o”的正则表达式。（当不
;;   区分大小写时，前面的两个式子也匹配“F”和“O”，而实际上，一般认为它们是
;;   “同样的串”，并不是因为例外。）

;;       两个任意的表达式 A 和 B 可以连接，其结果是能够匹配以 A 开始，其余部分是
;;   B 的字符串的表达式。

;;       举个简单的例子，我们将表达式“f”和“o”连接，得到表达式“fo”，仅匹配
;;   串“fo”，很简单的。想做些不简单的，需要使用特殊字符。下面介绍这些特殊字符。

;; ** 特殊字符

;; *** “. (Period)”

;;       匹配除了换行符(newline)之外任何单个字符的特殊字符。通过“连接”，可以得
;;       到如“a.b”的表达式，匹配所有的以“a”开始，以“b”结束的三个字符的字符
;;       串。

;; *** “*”

;;       自身不构成表达式的部分，作为后缀操作符，表示某个前导表达式可以任意
;;       次重复。比如，“o*”匹配任意个“o”连成的串（包括空串）。

;;       “*”总是作用于“最少的”可能的前导表达式。于是，“fo*”中，可以重复的
;;       是“o”，而不是“fo”，匹配形如“f”, “fo”, “foo”的串等等。

;;       匹配程序以迅速且尽可能多的找到重复部分来处理带“*”的结构。然后继续其他
;;       部分的处理。如果失败了，为了使剩余的部分能够尽可能的匹配，匹配程序会回
;;       退，释放一些已经由“*”匹配的结构。例如，在使用“ca*ar”来匹配串
;;       “caaar”时，“a*”首先试图匹配全部的三个“a”；但余下的部分是“ar”，
;;       不能匹配“r”，失败；接着选择用“a*”匹配两个“a”，成功。

;; *** “+”

;;       和“*”相似的后缀操作符，它表示前导表达式要至少出现一次。例如，“ca+r”匹
;;       配串“car”和“caaaar”，但不能匹配“cr”。

;; *** “?”

;;       也是一个和“*”相似的操作符，它表示前导表达式至多出现一次。例如，
;;       “ca?r”仅仅匹配“car”或“cr”。

;; *** “*?, +?, ??”

;;       是前面几个操作符的非贪心(non-greedy)的变体。正常的“*”， “+”， “?”
;;       操作符是“贪心的(greedy)”，只要总体上能够匹配，这些操作符总是尽可能多
;;       的匹配。当紧跟着“?”时，则是非贪心的：将尽可能少的匹配。

;;       “ab*”和“ab*?”都能匹配串“a”和“abbbb”；但如果你试图用它们来匹配
;;       “abbbb”时，“ab*”将匹配全部（最长有效匹配），而“ab*?”将仅仅匹配
;;       “a”（最短有效匹配）。

;; *** “\{N\}”

;;       指定重复次数为 N 的后缀操作符，前导表达式必须恰好出现 N 次。例如
;;       “x\{4\}”仅匹配串“xxxx”。

;; *** “\{N,M\}”

;;       指定重复次数在N和M之间的后缀操作符，就是说它的前导表达式的出现次数至少
;;       是N 但不能超过 M。如果省略 M，表示没有上限，但它的前导表达式至少出现 N
;;       次。“\{0,1\}”等于“?”。“\{0,\}”等于“*”。“\{1,\}”等于“+”。

;; *** “[ ... ]”

;;       字符集，以“[”开始以“]”结束。最简单的例子，在两个方括号中间的字符就
;;       是这个集合所能匹配的全部。

;;       所以，“[ad]”仅匹配一个“a”或一个“d”，“[ad]*”匹配所有仅由“a”和
;;       “d”构成的串（和空串）。“c[ad]*r”匹配“cr”，“car”， “cdr”，
;;       “caddaar”，等等。

;;       也可以用一个“-”放在一个开始字符和一个结束字符的中间，表示字符集中字符
;;       的范围。“[a-z]”匹配所有小写 ASCII 字母。范围可以和单独的字符自由的组
;;       合在一起，比如“[a-z$%.]”，匹配了任意的小写字母，或“$”，“%”，以及
;;       “.”。

;;       注意，通常在字符集中的特殊字符不再特殊，而在字符集中的“]”，“-”和
;;       “^”却是特殊字符。

;;       如果想在字符集中包括字符“]”，必须放在第一个字符位置。例如，“[]a]”匹
;;       配“]”或“a”。想包括“-”，要在第一个或最后一个位置，或在一个范围的后
;;       面，如“[]-]”匹配“]”和“-”。

;;       如果想在字符集中包括字符“^”，不可以放在第一个位置。（在开始位置，它会
;;       把这个字符集取补――看下面。）

;;       当不区分大小写使用范围时，表示范围的两个字符或者都是大写、或者都是小写、
;;       或者都不是字母。混合大小写的范围如“A-z”意思不明确，不被接受，或许在将
;;       来的 Emacs 中会被改变。

;; *** “[^ ... ]”
;;       “[^”表示“补集合”，匹配的字符是除掉指定的字符外其他所有的字符。如，
;;       “[^a-z0-9A-Z]”匹配除掉ASCII字母和数字的所有字符。

;;       当“^”在字符集中第一个时，被看作是特殊字符。而跟在“^”后面的字符被看
;;       作是第一个字符（就是说，此处的“-”和“]”将不是特殊的）。

;;       一个补集合可以匹配换行符，除非换行符被指定为补集合中的一个字符。这不同
;;       于某些象“grep”的程序对正则表达式的处理。

;; *** “^”
;;       仅仅匹配在文本中行首的那个空串的特殊字符。就是说，“^foo”匹配在行首的
;;       “foo”。

;; *** “$”
;;       和“^”相似，但仅匹配行尾的空串。因此“x+$”匹配在行尾的一个或多个“x”
;;       的串。

;; *** “\”
;;       有两个作用：引用特殊字符（包括“\”）；产生附加的特殊结构。

;;       因为“\”引用特殊字符，“\$”是一个仅匹配“$”的表达式，“\[”是一个仅
;;       匹配“[”的表达式，等等。

;; ** 关于反斜线
;;       注意：为兼容性考虑，特殊字符，如果在其没有意义的上下文中，将被当作普通
;;   字符。比如：“*foo”中把“*”当作普通字符，因为在它前面没有可以作用的前导表
;;   达式。很少有人会根据这条规则去实践；无论如何，在任何地方都加上引用会更好些。

;;       对于大多数情况，“\”后接任何字符仅仅匹配那个字符。然而，有几个例外：
;;   以“\”开始的两字符序列会有特殊的意思。其中的第二个字符往往是普通字符。下
;;   面是“\”的结构表。

;; *** “\|”
;;       指定一个选择。中间有一个“\|”的两个正则表达式 A 和 B，形成了一个可以匹
;;       配 A 或 B 的文本。它首先试图用 A 匹配，如果失败再用 B 去试。

;;       由此，“foo\|bar”仅匹配“foo”或“bar”。

;;       “\|”作用于两边最长的可能的表达式。仅由“\( ... \)”括起来才可以限制
;;       “\|”的分组能力。

;;       Emacs 有全面的回退功能，以处理“\|”的多种的用途。

;; *** “\( ... \)”
;;       分组结构，有三个功能：

;;         1.围住“\|”的选择项，以实现别的操作。例如“\(foo\|bar\)x”匹配
;;           “foox”或“barx”。

;;         2.围住复杂的表达式以实现后缀操作符（如“*”“+”和“?”）的操作。例如
;;           “ba\(na\)*”匹配如“bananana”等，有任意个（零或更多）的“na”串。

;;         3.记录一个已匹配的子串用作后面的参考引用。

;;       最后一个应用并不是括号的分组功能思想的结果；这个分开的特点是给同样的
;;       “\( ... \)”结构赋予的第二种含义。在实际应用中，这两种含义通常不会发生
;;       冲突。当发生冲突的时候，可以使用“谨慎的”分组("shy" group)。

;; *** “\(?: ... \)”
;;       “谨慎的”分组("shy" group)，这个分组不记录匹配的子串；你不能用“\D”来
;;       引用。这在机械的结合正则表达式的时候有用，这样，你可以为语法目的加入分
;;       组，而不用干涉使用者写的分组的个数。

;; *** “\D”
;;       匹配和“\( ... \)”结构第 D 次出现时所匹配的同样的文本。

;;       在“\( ... \)”结构结束之后，匹配程序保存被这个结构匹配的文本（的开始和
;;       结束）；之后的正则表达式中，你可以使用“\”跟着一个数字 D 来表示“匹配
;;       和‘\( ... \)’结构第 D 次出现时所匹配的同样的文本。”

;;       正则表达式中前九个出现的“\( ... \)”结构，按正则表达式中左括号出现的次
;;       序从 1 到 9 赋值。因此可以用“\1”到“\9”来引用相应的“\( ... \)”结构。

;;       例如，“\(.*\)\1”匹配任何有完全相同的两部分而无换行符的串。“\(.*\)”
;;       匹配前一半，可以是任意的串，“\1”匹配后面的，但必须和前面的完全相同。

;;       如果一个特定的“\( ... \)”结构匹配了多次（比如后面有一个“*”，这很显
;;       然），那么仅记录最后一次的匹配。

;; *** “\`”
;;       匹配空串，但仅是接在缓冲区的开始处的。

;; *** “\'”
;;       匹配空串，但仅是接在缓冲区的尾部的。

;; *** “\=”
;;       匹配空串，但仅在“点(point)”处的。

;; *** “\b”
;;       匹配空串，但仅在一个词的开始或者结尾的。例如，“\bfoo\b”匹配任何作为单
;;       独的词出现的“foo”。“\bballs?\b”匹配作为单独的词出现的“ball”或
;;       “balls”。

;;       在缓冲区的开始和结束位置时，“\b”不考虑紧接其前的文本是什么。

;; *** “\B”
;;       匹配空串，但不在词的开始或结尾处。

;; *** “\<”
;;       匹配空串，但仅在词的开始处。仅当一个构成词的字符在缓冲区开始处时“\<”
;;       匹配缓冲区开始处的空串。

;; *** “\>”
;;       匹配空串，但仅在词的结尾处。仅当缓冲区尾部有构成词的字符时“\>”匹配缓
;;       冲区尾部的空串。

;; *** “\w”
;;       匹配任何构成词的字符。由语法表决定这些字符是什么。

;; *** “\W”
;;       匹配任何非构成词的字符。

;; *** “\sC”
;;       匹配任何语法是 C 的字符。这里 C 是一个指定特定语法类的字符：如“w”为词
;;       的构成字符，“-”或“ ”为空白，“.”为普通标点符号，等等。

;; *** “\SC”
;;       匹配任何字符不属于语法 C。

;; *** “\cC”
;;       匹配任何属于种类 C 的字符。例如，“\cc”匹配汉字，“\cg”匹配希腊字符等。
;;       如果想了解已知种类，用“M-x describe-categories <RET>”。

;; *** “\CC”
;;       匹配所有不属于种类C的字符。

;;     属于词和语法的结构是由语法表的设置来控制的。

;; ** 例
;;         下面是一个复杂的正则表达式，存储在“sentence-end”，Emacs 将其用于识
;;     别句子的结束以及后面的任何空白。其中以 Lisp 语法区分了空白符和制表符。在
;;     Lisp 语法中，串常量用双引号括起来。“\"”表示双引号是表达式的一部分，
;;     “\\”表示反斜扛是表达式的一部分，“\t”表示制表符，“\n”表示换行。

;;          "[.?!][]\"')]*\\($\\| $\\|\t\\|  \\)[ \t\n]*"

;;     其中包含四个连续的部分：匹配句号(“.”)、“?”或“!”的字符集；匹配右方括
;;     号、右(单/双)引号的字符集的任意次重复的部分；在“反斜线括号”部分中，匹配
;;     行尾、行尾空白、制表符或两个空格的可选集合；以及一个任意次匹配空白的字符
;;     集。

;;         在增量搜索中，要用 <TAB> 输入制表符，“C-j”输入换行符。也可以使用单
;;     独的反斜线，不用象 Lisp 串中那样写成两个。
